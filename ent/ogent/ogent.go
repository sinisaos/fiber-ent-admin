// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/go-faster/jx"
	"github.com/sinisaos/fiber-ent-admin/ent"
	"github.com/sinisaos/fiber-ent-admin/ent/answer"
	"github.com/sinisaos/fiber-ent-admin/ent/question"
	"github.com/sinisaos/fiber-ent-admin/ent/tag"
	"github.com/sinisaos/fiber-ent-admin/ent/user"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateAnswer handles POST /answers requests.
func (h *OgentHandler) CreateAnswer(ctx context.Context, req *CreateAnswerReq) (CreateAnswerRes, error) {
	b := h.client.Answer.Create()
	// Add all fields.
	b.SetContent(req.Content)
	b.SetCreatedAt(req.CreatedAt)
	// Add all edges.
	if v, ok := req.Question.Get(); ok {
		b.SetQuestionID(v)
	}
	if v, ok := req.Author.Get(); ok {
		b.SetAuthorID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Answer.Query().Where(answer.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewAnswerCreate(e), nil
}

// ReadAnswer handles GET /answers/{id} requests.
func (h *OgentHandler) ReadAnswer(ctx context.Context, params ReadAnswerParams) (ReadAnswerRes, error) {
	q := h.client.Answer.Query().Where(answer.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewAnswerRead(e), nil
}

// UpdateAnswer handles PATCH /answers/{id} requests.
func (h *OgentHandler) UpdateAnswer(ctx context.Context, req *UpdateAnswerReq, params UpdateAnswerParams) (UpdateAnswerRes, error) {
	b := h.client.Answer.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Content.Get(); ok {
		b.SetContent(v)
	}
	// Add all edges.
	if v, ok := req.Question.Get(); ok {
		b.SetQuestionID(v)
	}
	if v, ok := req.Author.Get(); ok {
		b.SetAuthorID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Answer.Query().Where(answer.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewAnswerUpdate(e), nil
}

// DeleteAnswer handles DELETE /answers/{id} requests.
func (h *OgentHandler) DeleteAnswer(ctx context.Context, params DeleteAnswerParams) (DeleteAnswerRes, error) {
	err := h.client.Answer.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteAnswerNoContent), nil

}

// ListAnswer handles GET /answers requests.
func (h *OgentHandler) ListAnswer(ctx context.Context, params ListAnswerParams) (ListAnswerRes, error) {
	q := h.client.Answer.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewAnswerLists(es)
	return (*ListAnswerOKApplicationJSON)(&r), nil
}

// ReadAnswerQuestion handles GET /answers/{id}/question requests.
func (h *OgentHandler) ReadAnswerQuestion(ctx context.Context, params ReadAnswerQuestionParams) (ReadAnswerQuestionRes, error) {
	q := h.client.Answer.Query().Where(answer.IDEQ(params.ID)).QueryQuestion()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewAnswerQuestionRead(e), nil
}

// ReadAnswerAuthor handles GET /answers/{id}/author requests.
func (h *OgentHandler) ReadAnswerAuthor(ctx context.Context, params ReadAnswerAuthorParams) (ReadAnswerAuthorRes, error) {
	q := h.client.Answer.Query().Where(answer.IDEQ(params.ID)).QueryAuthor()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewAnswerAuthorRead(e), nil
}

// CreateQuestion handles POST /questions requests.
func (h *OgentHandler) CreateQuestion(ctx context.Context, req *CreateQuestionReq) (CreateQuestionRes, error) {
	b := h.client.Question.Create()
	// Add all fields.
	b.SetTitle(req.Title)
	b.SetContent(req.Content)
	b.SetCreatedAt(req.CreatedAt)
	// Add all edges.
	b.AddAnswerIDs(req.Answers...)
	if v, ok := req.Author.Get(); ok {
		b.SetAuthorID(v)
	}
	b.AddTagIDs(req.Tags...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Question.Query().Where(question.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewQuestionCreate(e), nil
}

// ReadQuestion handles GET /questions/{id} requests.
func (h *OgentHandler) ReadQuestion(ctx context.Context, params ReadQuestionParams) (ReadQuestionRes, error) {
	q := h.client.Question.Query().Where(question.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewQuestionRead(e), nil
}

// UpdateQuestion handles PATCH /questions/{id} requests.
func (h *OgentHandler) UpdateQuestion(ctx context.Context, req *UpdateQuestionReq, params UpdateQuestionParams) (UpdateQuestionRes, error) {
	b := h.client.Question.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Title.Get(); ok {
		b.SetTitle(v)
	}
	if v, ok := req.Content.Get(); ok {
		b.SetContent(v)
	}
	// Add all edges.
	if req.Answers != nil {
		b.ClearAnswers().AddAnswerIDs(req.Answers...)
	}
	if v, ok := req.Author.Get(); ok {
		b.SetAuthorID(v)
	}
	if req.Tags != nil {
		b.ClearTags().AddTagIDs(req.Tags...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Question.Query().Where(question.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewQuestionUpdate(e), nil
}

// DeleteQuestion handles DELETE /questions/{id} requests.
func (h *OgentHandler) DeleteQuestion(ctx context.Context, params DeleteQuestionParams) (DeleteQuestionRes, error) {
	err := h.client.Question.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteQuestionNoContent), nil

}

// ListQuestion handles GET /questions requests.
func (h *OgentHandler) ListQuestion(ctx context.Context, params ListQuestionParams) (ListQuestionRes, error) {
	q := h.client.Question.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewQuestionLists(es)
	return (*ListQuestionOKApplicationJSON)(&r), nil
}

// ListQuestionAnswers handles GET /questions/{id}/answers requests.
func (h *OgentHandler) ListQuestionAnswers(ctx context.Context, params ListQuestionAnswersParams) (ListQuestionAnswersRes, error) {
	q := h.client.Question.Query().Where(question.IDEQ(params.ID)).QueryAnswers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewQuestionAnswersLists(es)
	return (*ListQuestionAnswersOKApplicationJSON)(&r), nil
}

// ReadQuestionAuthor handles GET /questions/{id}/author requests.
func (h *OgentHandler) ReadQuestionAuthor(ctx context.Context, params ReadQuestionAuthorParams) (ReadQuestionAuthorRes, error) {
	q := h.client.Question.Query().Where(question.IDEQ(params.ID)).QueryAuthor()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewQuestionAuthorRead(e), nil
}

// ListQuestionTags handles GET /questions/{id}/tags requests.
func (h *OgentHandler) ListQuestionTags(ctx context.Context, params ListQuestionTagsParams) (ListQuestionTagsRes, error) {
	q := h.client.Question.Query().Where(question.IDEQ(params.ID)).QueryTags()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewQuestionTagsLists(es)
	return (*ListQuestionTagsOKApplicationJSON)(&r), nil
}

// CreateTag handles POST /tags requests.
func (h *OgentHandler) CreateTag(ctx context.Context, req *CreateTagReq) (CreateTagRes, error) {
	b := h.client.Tag.Create()
	// Add all fields.
	b.SetName(req.Name)
	// Add all edges.
	b.AddQuestionIDs(req.Questions...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Tag.Query().Where(tag.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTagCreate(e), nil
}

// ReadTag handles GET /tags/{id} requests.
func (h *OgentHandler) ReadTag(ctx context.Context, params ReadTagParams) (ReadTagRes, error) {
	q := h.client.Tag.Query().Where(tag.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTagRead(e), nil
}

// UpdateTag handles PATCH /tags/{id} requests.
func (h *OgentHandler) UpdateTag(ctx context.Context, req *UpdateTagReq, params UpdateTagParams) (UpdateTagRes, error) {
	b := h.client.Tag.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	if req.Questions != nil {
		b.ClearQuestions().AddQuestionIDs(req.Questions...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Tag.Query().Where(tag.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTagUpdate(e), nil
}

// DeleteTag handles DELETE /tags/{id} requests.
func (h *OgentHandler) DeleteTag(ctx context.Context, params DeleteTagParams) (DeleteTagRes, error) {
	err := h.client.Tag.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTagNoContent), nil

}

// ListTag handles GET /tags requests.
func (h *OgentHandler) ListTag(ctx context.Context, params ListTagParams) (ListTagRes, error) {
	q := h.client.Tag.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTagLists(es)
	return (*ListTagOKApplicationJSON)(&r), nil
}

// ListTagQuestions handles GET /tags/{id}/questions requests.
func (h *OgentHandler) ListTagQuestions(ctx context.Context, params ListTagQuestionsParams) (ListTagQuestionsRes, error) {
	q := h.client.Tag.Query().Where(tag.IDEQ(params.ID)).QueryQuestions()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTagQuestionsLists(es)
	return (*ListTagQuestionsOKApplicationJSON)(&r), nil
}

// CreateUser handles POST /users requests.
func (h *OgentHandler) CreateUser(ctx context.Context, req *CreateUserReq) (CreateUserRes, error) {
	b := h.client.User.Create()
	// Add all fields.
	b.SetUsername(req.Username)
	b.SetEmail(req.Email)
	b.SetPassword(req.Password)
	b.SetCreatedAt(req.CreatedAt)
	b.SetSuperuser(req.Superuser)
	// Add all edges.
	b.AddQuestionIDs(req.Questions...)
	b.AddAnswerIDs(req.Answers...)
	b.AddTagIDs(req.Tags...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserCreate(e), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req *UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Username.Get(); ok {
		b.SetUsername(v)
	}
	if v, ok := req.Email.Get(); ok {
		b.SetEmail(v)
	}
	if v, ok := req.Password.Get(); ok {
		b.SetPassword(v)
	}
	if v, ok := req.Superuser.Get(); ok {
		b.SetSuperuser(v)
	}
	// Add all edges.
	if req.Questions != nil {
		b.ClearQuestions().AddQuestionIDs(req.Questions...)
	}
	if req.Answers != nil {
		b.ClearAnswers().AddAnswerIDs(req.Answers...)
	}
	if req.Tags != nil {
		b.ClearTags().AddTagIDs(req.Tags...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserLists(es)
	return (*ListUserOKApplicationJSON)(&r), nil
}

// ListUserQuestions handles GET /users/{id}/questions requests.
func (h *OgentHandler) ListUserQuestions(ctx context.Context, params ListUserQuestionsParams) (ListUserQuestionsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryQuestions()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserQuestionsLists(es)
	return (*ListUserQuestionsOKApplicationJSON)(&r), nil
}

// ListUserAnswers handles GET /users/{id}/answers requests.
func (h *OgentHandler) ListUserAnswers(ctx context.Context, params ListUserAnswersParams) (ListUserAnswersRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryAnswers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserAnswersLists(es)
	return (*ListUserAnswersOKApplicationJSON)(&r), nil
}

// ListUserTags handles GET /users/{id}/tags requests.
func (h *OgentHandler) ListUserTags(ctx context.Context, params ListUserTagsParams) (ListUserTagsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryTags()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserTagsLists(es)
	return (*ListUserTagsOKApplicationJSON)(&r), nil
}
